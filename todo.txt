[bug] The flickr save won't save if the local store directory is not there. Maybe we need a solution that can maintain these directories and perhaps history associated with them.

[bug] With the flickr RSS feed sometimes it picks an URL that does not look like an image,
    like the creative commons licensing stuff. Test with script-flickr-save.json

[x] we need some new architecture to serving images feed flow: at this point we save all images from a
    a feed to the actual localstore. The new version should create a fresh — downloading — directory and fetch all them in there. Then when the operation is done ( full directory loaded with images ) 
   it moves these images to an actual about/store/localpictures/serving direectory. So the idea here
   is that a store directory will have some contextual states: default, serving, and history. 

[w] if there is a 'to' it will will create an event for that. So we should report an error
    in this case. Let's say an end event, result=ok, does a to='statenew' and statenew
    does not exist. 

[x] Workout / create the /store/images/image-by-date-xxx.jpg to quality check and to make them available via an 
    RSS. So a new rule to probably become ( list, organize, and wrap to serve ) wrapToFeed that makes  
    a feed that calls images from the store. This means " serving state " . See script-flickr.json example

[x] Check the ./action/loadRSS.js design clearTimeouts ; see following redesigned approach for timeouts.

[x] Need to move the DNS use case to ./tests/ scripts. We need to be able to grab data from the tests and to measure
ehe pass no pass for everything.; This solution may simply be what we doing now, scripts-xxx.json but we may need
to workout some more the expectations stuff = how we measure the outputs, data astore, etc.  

[x] Some of action scripts may generate an exception that has a lot of messages. As we wrap these 
    in the out.send ( and out.senderr ) we get now a propoerly formated json which is quite strange 
    example: 

    =={"result":"error","data":{"stack":"Error: ENOENT, No such file or directory 'channel/store/logo/image-2012-01-18T21:13:29.804Z.jpg'","message":"ENOENT, No such file or directory 'channel/store/logo/image-2012-01-18T21:13:29.804Z.jpg'","errno":2,"code":"ENOENT","path":"channel/store/logo/image-2012-01-18T21:13:29.804Z.jpg"}}==

[x] Rewrite the whole timer problem. Right now we have a timer that is statically in the 
    ./action/loadRSS.js script. When the script process is up, the timer ( setTimeout ) 
    starts and then if the script is not finished ( result=ok + clearTimeout ) then what 
    happens is that the timer ends up kicking the stderr ( or should it be stdout ) 
    with a result=expired code. This is how we do the timer now. And when the expiration comes to the 
    actual mediator/run/execFlow, we don't even treat right now. In the traditional way of doing, 
    if we maintain this code, the solution would be to put conditions in the ./script.js and 
    so the script.json would have the cases ( ok, err, expired, etc ). 

    Perhaps another approach, for this timer, is to think a model of expectations. The reason we may think 
    about this is because some of our use case has more than one network action so our real expectation, 
    when thinking about expiration timers, is to wait for the whole thing and not each individual step. So, 
    for example, in the resize picts from flickr case, 1-step is load RSS, 2-step is bring images, 3-step 
    is save image, resize and serve. So what we want in this case is simply to set an expiration to the actual 
    expected final result. For example 

    about:'flickrstart', 
    function: checkState, 
    data:'about/flickr/load/saved/resized',
    to:'allThingsAreReady',
    data:15000, 
    
     
    
    
